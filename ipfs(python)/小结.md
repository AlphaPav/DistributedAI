## IPFS ##
### 优点 ###
星际文件系统IPFS（InterPlanetary File System）是一个面向全球的、点对点的分布式版本文件系统，目标是为了补充（甚至是取代）目前统治互联网的超文本传输协议（HTTP），将所有具有相同文件系统的计算设备连接在一起。原理用基于内容的地址替代基于域名的地址，也就是用户寻找的不是某个地址而是储存在某个地方的内容，不需要验证发送者的身份，而只需要验证内容的哈希，通过这样可以让网页的速度更快、更安全、更健壮、更持久。  
IPFS和区块链能够完美结合，用户可以使用IPFS来存储大量数据，然后把对应的加密哈希存储到区块链中并打上时间戳。这样就无需将数据本身放在链上，不但可以节省区块链的网络带宽，还可以对其进行有效保护。关于文件的安全性，一方面可以加密后存入IPFS，另一方面也可利用IPFS实现文件分布式共享。IPFS弥补了现有区块链系统在文件存储方面的短板，将IPFS的永久文件存储和区块链的不可篡改、时间戳证明特性结合，非常适合在版权保护、身份及来源证明等方面加以应用。  同时，用基于区块链的代币来激励IPFS节点存储数据也是不错的选择。两者结合，能够共同构建去中心化的网络世界。
### 缺点 ###
通过哈希值就可以下载存在IPFS网络上的文档，安全性不足。
### 参考文献(强烈推荐的部分) ###
[Whitepaper](https://ipfs.io/ipfs/QmR7GSQM93Cx5eAg6a6yRzNde1FQv7uL6X1o4k7zrJa3LX/ipfs.draft3.pdf)  
[Learn to securely share files on the blockchain with IPFS!](https://medium.com/@mycoralhealth/learn-to-securely-share-files-on-the-blockchain-with-ipfs-219ee47df54c)  
[详解IPFS的本质、技术架构以及应用](http://www.8btc.com/ipfs-application)  
[IPFS入门笔记](https://blog.csdn.net/DL88250/article/details/78579080)


## Storj ##
### 优点 ###
Storj把用户自己加密过的文档split into shards,再把各个shards存到network，安全性增加。
### 缺点 ###
注重挖矿，国内外资料中对于storj原理和存储的介绍较少。
### 参考文献 ###
[Whitepaper](https://bravenewcoin.com/assets/Whitepapers/storj.pdf)


## 我们的project: fms(file manage system) ##
### 优点 ###
使用加密和Shard技术把加密过的文件分块存储到IPFS上。  
只有拥有加密过的密钥和一个解密这个密钥的私钥，以及shards的哈希值才能获得一个原始的完整文件。  
结合了IPFS和Storj的优点。  
### 历程 ###
初步确定的方案是：  
1、加密整个文档。  
2、分割成单独的部分。  
3、上传文件到IPFS并存储各个部分的哈希值。  
4、从记录的文档哈希中下载各个部分。  
5、合并文档。  
6、解密。  
  
在一开始的代码编写过程中，分割/合并文档、上传/下载文档在一个上午的时间内便已经实现了，但是加密解密却出现一些问题。  
我们一开始使用的是RSA加密，因为RSA是非对称加密，公钥负责加密，私钥负责解密，但是这种加密方式只能加密比密匙短的文档，加密范围太小，因此我们后来改用AES和RSA结合的加密算法。AES是对称加密，它的特点是文件加密和解密使用相同的密钥。（后来发现Storj的Whitepaper也推荐AES加密，不谋而合啦）  
在AES算法实现过程中，参考了网上代码，网上大部分只加密字符串，因此在我们书写的过程中遇到了编码问题。  
好不容易将字符串的问题解决，在我们测试非文本文档的时候发生了不可转码的问题，发现是其他格式的文档不能以字符串的形式保存。  
我们又开始尝试以二进制读取文件，加密文件，终于能够成功。  
但是生成的AES-KEY无法编码成字符串，无法存入HashRecord.txt，存成两个文档十分麻烦，因此我们将加密过AES-KEY存在文件中，上传ipfs，记录哈希值。  
在经过不断尝试之后，我们终于能够上传，存储任何文档。  
  
但是，今天我们试图上传一部2G电影之时，AES加密算法开始报错，原因是加密的文件长度太大，内存爆炸。  
因此，我们做了调整：  
  
1、分割成单独的部分。  
2、加密各个部分。  
3、上传文件并存储各个部分的哈希值。  
4、从记录的文档哈希中下载各个部分。  
5、解密所有文档。  
6、合并。  
  
这样一来，文件的大小必须符合加密的要求，大小是16的倍数，将加密块的大小设置为：
chunksize = int(math.pow(16,int(math.log(totalSize, 16))))
因此，分块数量会分布在1-16。  
同时，限制最大值为32M，防止内存不足。  
这样一来，重新测试2G视频，OK，上传下载都很成功，我们推测我们的程序可以上传任意大小任意格式的文件，前提是至少拥32M的硬盘。  